### Примеры запросов

**Пример 1: JOIN трех таблиц**

```sql
SELECT
    o.order_id,
    c.name AS customer,
    p.name AS product,
    oi.quantity,
    cat.name AS category
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id;
```

**Пример 2: Смешанные типы JOIN**

```sql
SELECT
    c.name AS customer,
    o.order_id,
    p.name AS product,
    COALESCE(oi.quantity, 0) AS quantity
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.product_id;
```

**Пример 3: JOIN с подзапросом**

```sql
SELECT
    c.name,
    c.total_orders,
    o.product,
    o.amount
FROM (
    SELECT
        customer_id,
        name,
        COUNT(*) OVER (PARTITION BY customer_id) AS total_orders
    FROM customers
) c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE c.total_orders > 1;
```

---

## Условия JOIN

JOIN может использовать различные условия соединения.

### Типы условий

**1. Равенство (наиболее распространенное)**

```sql
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.id = t2.id;
```

**2. Неравенство**

```sql
SELECT *
FROM products p1
INNER JOIN products p2
ON p1.price < p2.price;
```

**3. Множественные условия**

```sql
SELECT *
FROM orders o
INNER JOIN shipments s
ON o.order_id = s.order_id
   AND o.warehouse_id = s.warehouse_id;
```

**4. USING (для одинаковых названий столбцов)**

```sql
SELECT *
FROM customers
INNER JOIN orders
USING (customer_id);
```

**5. NATURAL JOIN (автоматическое соединение по одинаковым столбцам)**

```sql
SELECT *
FROM customers
NATURAL JOIN orders;
```

### Примеры сложных условий

**Пример 1: JOIN с диапазоном дат**

```sql
SELECT
    e.name AS employee,
    p.project_name,
    p.start_date,
    p.end_date
FROM employees e
INNER JOIN projects p
ON e.hire_date <= p.end_date
   AND (e.termination_date IS NULL OR e.termination_date >= p.start_date);
```

**Пример 2: JOIN с CASE**

```sql
SELECT
    o.order_id,
    o.amount,
    CASE
        WHEN d.discount_percent IS NOT NULL THEN o.amount * (1 - d.discount_percent/100)
        ELSE o.amount
    END AS final_amount
FROM orders o
LEFT JOIN discounts d
ON o.customer_id = d.customer_id
   AND o.order_date BETWEEN d.start_date AND d.end_date;
```

**Пример 3: JOIN с функциями**

```sql
SELECT
    u1.username AS user1,
    u2.username AS user2
FROM users u1
INNER JOIN users u2
ON LOWER(u1.email_domain) = LOWER(u2.email_domain)
   AND u1.user_id < u2.user_id;
```

---

## Производительность

### Индексы

Использование индексов значительно ускоряет JOIN операции.

```sql
-- Создание индекса для улучшения производительности JOIN
CREATE INDEX idx_customer_id ON orders(customer_id);
CREATE INDEX idx_product_id ON order_items(product_id);
```

### Оптимизация запросов

**1. Фильтрация до JOIN**

```sql
-- Медленно
SELECT *
FROM large_table1 t1
INNER JOIN large_table2 t2
ON t1.id = t2.id
WHERE t1.date > '2024-01-01';

-- Быстрее
SELECT *
FROM (SELECT * FROM large_table1 WHERE date > '2024-01-01') t1
INNER JOIN large_table2 t2
ON t1.id = t2.id;
```

**2. Выбор нужных столбцов**

```sql
-- Избегайте SELECT *
SELECT
    c.customer_id,
    c.name,
    o.order_id,
    o.amount
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;
```

**3. Использование EXISTS вместо JOIN**

```sql
-- Когда нужно проверить существование
SELECT c.name
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);
```

### EXPLAIN PLAN

Используйте EXPLAIN для анализа запросов:

```sql
EXPLAIN
SELECT
    c.name,
    COUNT(o.order_id) AS order_count
FROM customers c
LEFT JOIN orders o
ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;
```

---

## Лучшие практики

### 1. Всегда используйте алиасы

```sql
-- Хорошо
SELECT
    c.name,
    o.order_date
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;

-- Плохо
SELECT
    customers.name,
    orders.order_date
FROM customers
INNER JOIN orders
ON customers.customer_id = orders.customer_id;
```

### 2. Явно указывайте тип JOIN

```sql
-- Хорошо
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.id = t2.id;

-- Избегайте неявных JOIN
SELECT *
FROM table1 t1, table2 t2
WHERE t1.id = t2.id;
```

### 3. Проверяйте NULL значения

```sql
SELECT
    c.name,
    COALESCE(COUNT(o.order_id), 0) AS order_count
FROM customers c
LEFT JOIN orders o
ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;
```

### 4. Упорядочивайте JOIN логично

```sql
-- От главной таблицы к зависимым
SELECT *
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id;
```

### 5. Документируйте сложные JOIN

```sql
-- Соединяем клиентов с их заказами и продуктами
-- Включаем только активных клиентов с заказами за последний год
SELECT
    c.name,
    o.order_date,
    p.product_name
FROM customers c
INNER JOIN orders o
    ON c.customer_id = o.customer_id
INNER JOIN order_items oi
    ON o.order_id = oi.order_id
INNER JOIN products p
    ON oi.product_id = p.product_id
WHERE c.status = 'active'
    AND o.order_date >= CURRENT_DATE - INTERVAL '1 year';
```

### 6. Избегайте избыточных JOIN

```sql
-- Если данные можно получить без JOIN, не используйте его
-- Вместо JOIN с таблицей только для проверки существования
-- используйте EXISTS или IN
```

### 7. Тестируйте производительность

```sql
-- Используйте EXPLAIN ANALYZE для замера реального времени выполнения
EXPLAIN ANALYZE
SELECT
    c.name,
    COUNT(*) AS order_count
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;
```

---

## Распространенные ошибки и их решения

### 1. Дублирование строк

**Проблема:**

```sql
SELECT
    c.name,
    c.email
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;
-- Клиент с несколькими заказами появится несколько раз
```

**Решение:**

```sql
SELECT DISTINCT
    c.name,
    c.email
FROM customers c
INNER JOIN orders o
ON c.customer_id = o.customer_id;
```

### 2. Неожиданные NULL значения

**Проблема:**

```sql
SELECT
    c.name,
    o.order_date
FROM customers c
LEFT JOIN orders o
ON c.customer_id = o.customer_id
WHERE o.amount > 1000;
-- LEFT JOIN превращается в INNER JOIN из-за WHERE
```

**Решение:**

```sql
SELECT
    c.name,
    o.order_date
FROM customers c
LEFT JOIN orders o
ON c.customer_id = o.customer_id
    AND o.amount > 1000;
-- Или
WHERE o.amount > 1000 OR o.amount IS NULL;
```

### 3. Декартово произведение

**Проблема:**

```sql
SELECT *
FROM table1, table2;
-- Забыли условие JOIN
```

**Решение:**

```sql
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.id = t2.id;
```

---

## Заключение

JOIN операции - это фундаментальная часть работы с реляционными базами данных. Понимание различных типов JOIN и умение их правильно применять критически важно для эффективной работы с SQL.

### Ключевые моменты:

- **INNER JOIN** - для данных, которые должны существовать в обеих таблицах
- **LEFT JOIN** - когда нужны все записи из левой таблицы
- **RIGHT JOIN** - когда нужны все записи из правой таблицы
- **FULL OUTER JOIN** - когда нужны все записи из обеих таблиц
- **CROSS JOIN** - для создания всех возможных комбинаций
- **SELF JOIN** - для сравнения записей внутри одной таблицы

Всегда помните о производительности, используйте индексы и правильно формулируйте условия JOIN для достижения наилучших результатов.
