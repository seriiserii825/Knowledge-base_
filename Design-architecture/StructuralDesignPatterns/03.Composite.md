Классический пример — файловая система:

File — лист (leaf): у него есть размер, но внутри ничего нет.
Folder — составной объект (composite): содержит файлы и другие папки, но при этом:
тоже имеет имя,
тоже можно спросить «какой твой размер?».
Клиентскому коду не хочется постоянно писать:

```ts
if (isFile) {
  // ...
} else if (isFolder) {
  // ...
}
```

Хочется иметь единый интерфейс FileSystemItem и вызывать getSize() и print() у чего угодно.

### Формальное определение

Composite — структурный паттерн, который:

- описывает единый интерфейс для листа и контейнера;
- позволяет строить древовидные структуры (объект, состоящий из под-объектов);
- делает так, что клиентскому коду не важно, работает он с одиночным объектом или с целой под-структурой.

### Структура паттерна

Component (компонент)
Общий интерфейс/абстрактный класс:

общие методы (например, getPrice(), render(), getSize()).

Leaf (лист)

Реальная сущность без «детей» (кнопка, файл, товар).

Composite (составной объект)

Хранит список Component внутри себя.

Реализует методы за счёт обхода своих детей:

getPrice() → суммирует цены всех детей.

render() → рендерит детей.

Client

Работает с Component.

Не знает, лист это или composite.

Пример: меню сайта (TypeScript)
Представим меню, где:

есть обычные пункты (leaf),

есть выпадающие меню с вложенными пунктами (composite).

```typescript
// Общий интерфейс
interface MenuComponent {
  render(indent?: number): void;
}

// Лист — обычный пункт меню
class MenuItem implements MenuComponent {
  constructor(
    private label: string,
    private link: string,
  ) {}

  render(indent: number = 0): void {
    const prefix = " ".repeat(indent);
    console.log(`${prefix}- ${this.label} (${this.link})`);
  }
}

// Composite — меню, которое может содержать пункты и подменю
class MenuGroup implements MenuComponent {
  private children: MenuComponent[] = [];

  constructor(private label: string) {}

  add(child: MenuComponent): void {
    this.children.push(child);
  }

  remove(child: MenuComponent): void {
    this.children = this.children.filter((c) => c !== child);
  }

  render(indent: number = 0): void {
    const prefix = " ".repeat(indent);
    console.log(`${prefix}${this.label}:`);

    for (const child of this.children) {
      child.render(indent + 2);
    }
  }
}

// Использование
const mainMenu = new MenuGroup("Main menu");

const home = new MenuItem("Home", "/");
const about = new MenuItem("About", "/about");

const services = new MenuGroup("Services");
services.add(new MenuItem("Web Development", "/services/web"));
services.add(new MenuItem("SEO", "/services/seo"));

const contact = new MenuItem("Contact", "/contact");

mainMenu.add(home);
mainMenu.add(about);
mainMenu.add(services);
mainMenu.add(contact);

// Клиенту не важно, item это или group
mainMenu.render();
```

Вывод будет примерно:

text
Copy code
Main menu:

- Home (/)
- About (/about)
  Services:
  - Web Development (/services/web)
  - SEO (/services/seo)
- Contact (/contact)
  Когда Composite полезен
  Деревья:

дерево страниц, меню, sitemap;

DOM-дерево, компоненты интерфейса;

категории/подкатегории товаров;

папки/файлы.

Когда операции одинаковые для части и целого:

посчитать суммарную цену (товар vs набор товаров);

отрендерить элемент (кнопка vs контейнер из кнопок);

посчитать размер (файл vs папка).

Когда не хочется плодить if (isGroup) { ... }.

Реальный пример ближе к фронту
UI-компоненты:

Button, Input — листы.

Form, Modal, Card — composite: содержат другие компоненты.

В TS можно сделать что-то вроде:

ts
Copy code
interface UIComponent {
mount(root: HTMLElement): void;
}

class Button implements UIComponent {
constructor(private label: string) {}

mount(root: HTMLElement): void {
const btn = document.createElement("button");
btn.textContent = this.label;
root.appendChild(btn);
}
}

class Container implements UIComponent {
private children: UIComponent[] = [];

add(component: UIComponent): void {
this.children.push(component);
}

mount(root: HTMLElement): void {
const div = document.createElement("div");
root.appendChild(div);

    for (const child of this.children) {
      child.mount(div);
    }

}
}

```

```
