Singleton в TypeScript — это просто класс, у которого может быть только один объект в приложении.
Не два, не десять — именно один «общий» экземпляр.

### 1. Зачем вообще нужен Singleton?

Типичные случаи, где логически нужен один общий объект:

Логгер (общий logger для всего приложения).

Глобальные настройки/конфиг.

Клиент для работы с API / базой данных.

EventBus / MessageBus.

Кэш / стор хранилища.

Идея:

если в системе должна существовать ровно одна сущность — мы можем обернуть её в Singleton.

### 2. Базовая реализация Singleton в TypeScript

Классический вариант:

```ts
class Singleton {
    // 1️⃣ Храним единственный экземпляр здесь
    private static instance: Singleton | null = null;

    // 2️⃣ Запрещаем создавать объекты через new снаружи
    private constructor() {
        console.log("Создан экземпляр Singleton");
    }

    // 3️⃣ Точка доступа к экземпляру
    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }

    public doSomething() {
        console.log("Работаю внутри Singleton");
    }
}

export default function example() {
    const s1 = Singleton.getInstance();
    const s2 = Singleton.getInstance();

    console.log(s1 === s2); // true — это один и тот же объект
    s1.doSomething();
}
```
### Ключевые моменты:


private constructor — нельзя сделать new Singleton() снаружи.

private static instance — статическое поле, где хранится единственный объект.

public static getInstance() — единственный способ получить экземпляр.

3. Пример 1: Logger как Singleton
Твоя типичная задача — логгер.
Исправлю и покажу корректный вариант (чтобы не было ошибки Property 'log' does not exist on type 'Logger'):

Вариант A: логгер с обычным методом log
ts
Копировать код
class Logger {
  private static instance: Logger | null = null;

  private constructor() {}

  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  public log(message: string) {
    const timestamp = new Date().toLocaleString();
    console.log(`[${timestamp}] - ${message}`);
  }
}

export default function singletonLogger() {
  const logger1 = Logger.getInstance();
  const logger2 = Logger.getInstance();

  logger1.log("First message");
  logger2.log("Second message");

  console.log(logger1 === logger2); // true
}
Почему раньше была ошибка?
У тебя метод log был static, но ты пытался вызвать его на экземпляре:

ts
Копировать код
public static log(message: string) { ... }

const logger_1 = Logger.getInstance();
logger_1.log("First message"); // ⛔ тут TS ругается
Либо:

делаешь log не static (как в примере выше),

либо вызываешь через Logger.log("...").

Вариант B: чисто статический Logger (по сути тоже Singleton)
Иногда делают просто «глобовый» логгер без getInstance():

ts
Копировать код
class StaticLogger {
  private constructor() {}

  public static log(message: string) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${message}`);
  }
}

export default function staticLoggerExample() {
  StaticLogger.log("Hello");
  StaticLogger.log("World");
}
Это уже больше «класс-утилита», но по сути выполняет ту же роль одной точки логирования.

4. Пример 2: ConfigService (настройки приложения)
Обычно настройки нужно прочитать один раз и использовать везде:

ts
Копировать код
type AppConfig = {
  apiBaseUrl: string;
  featureFlags: {
    betaMode: boolean;
  };
};

class ConfigService {
  private static instance: ConfigService | null = null;

  private config: AppConfig;

  private constructor() {
    // В реальном проекте можно читать .env, localStorage и т.п.
    this.config = {
      apiBaseUrl: "https://api.example.com",
      featureFlags: {
        betaMode: true,
      },
    };
  }

  public static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }

  public getConfig() {
    return this.config;
  }

  public isBetaEnabled() {
    return this.config.featureFlags.betaMode;
  }
}

export function configExample() {
  const configService = ConfigService.getInstance();
  console.log(configService.getConfig().apiBaseUrl);
  console.log(configService.isBetaEnabled());
}
Тут логически нам нужен один источник правды для конфигурации → Singleton норм.

5. Пример 3: API-клиент как Singleton
Чтобы не плодить тысячу fetch клиентов с одинаковым baseURL и заголовками:

ts
Копировать код
class ApiClient {
  private static instance: ApiClient | null = null;

  private constructor(
    private readonly baseUrl: string
  ) {}

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient("https://api.example.com");
    }
    return ApiClient.instance;
  }

  public async get<T>(path: string): Promise<T> {
    const res = await fetch(this.baseUrl + path);
    if (!res.ok) {
      throw new Error(`Request failed: ${res.status}`);
    }
    return res.json() as Promise<T>;
  }
}

export async function apiExample() {
  const api = ApiClient.getInstance();
  const data = await api.get<{ id: number; name: string }>("/users/1");
  console.log(data.name);
}
6. Когда Singleton уместен, а когда — нет
✅ Хорошо использовать, когда:
Есть один логический экземпляр в системе:

Logger

Config / Settings

EventBus

API-клиент

Создание объекта тяжёлое/дорогое, и нет смысла создавать много:

Подключение к БД

Кэш

⚠️ Осторожно: минусы
Глобальное состояние
Singleton часто превращается в «глобальную переменную с красивой маской».
Это усложняет тестирование и отладку.

Скрытые зависимости
В коде внезапно появляется MySingleton.getInstance(), хотя снаружи не видно, от чего реально зависит функция. Это нарушает явность зависимостей.

Тесты и мокирование
Подменять Singleton в тестах сложнее, чем передать зависимость через параметры или DI-контейнер.

Часто вместо «жёсткого» Singleton лучше:

использовать один объект, который создаётся в main и прокидывается вниз (через параметры, DI);

использовать обычные модули (export const logger = ...) — они в JS/TS и так по сути singleton по модулю.

7. «Singleton по-модульному» в TypeScript
Во многих случаях хватит вообще без классов:

ts
Копировать код
// logger.ts
export const logger = {
  log(message: string) {
    const timestamp = new Date().toLocaleString();
    console.log(`[${timestamp}] - ${message}`);
  },
};

// usage.ts
import { logger } from "./logger";

export function test() {
  logger.log("Hello from module singleton");
}
Модуль загружается один раз → logger по факту тоже singleton.
