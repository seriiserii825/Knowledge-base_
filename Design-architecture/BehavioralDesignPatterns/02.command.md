Паттерн Command — это способ превратить запрос (действие) в объект.
Тогда “что сделать” можно:

- передавать как данные;
- ставить в очередь;
- логировать;
- откатывать (undo/redo);
- комбинировать в макрокоманды.

Давай по структуре: что, зачем, когда и как — с примерами на TypeScript.

### 1. Что такое Command

Идея:
Вместо того чтобы напрямую вызывать receiver.doSomething(), мы создаём объект-команду, у которого есть метод execute().

Участники:

- Command — интерфейс команды (обычно execute(), часто ещё undo()).
- ConcreteCommand — конкретная команда, знает кого дернуть (receiver) и как.
- Receiver — “исполнитель”: реальный объект, который делает работу (документ, файл, сервис и т.п.).
- Invoker — тот, кто запускает команду (кнопка, меню, планировщик).
- Client — создает команды, соединяет всё вместе.

### 2. Зачем нужен Command

Основные выгоды:

- Развязка отправителя и получателя
- Invoker не знает, “что там внутри” действия — только вызывает command.execute().
- История действий и Undo/Redo
- Можно хранить список команд и откатывать: undo().
- Очереди, логирование, отложенное выполнение

Команды можно класть в очередь, запускать по расписанию, отправлять по сети.

Макрокоманды

Собрать несколько команд в одну: MacroCommand([c1, c2, c3]).

### 3. Когда применять Command

Типичные случаи:

- UI-слой: кнопки, меню, горячие клавиши
- Каждая кнопка — команда.
- Легко переиспользовать одну команду в разных местах (кнопка + шорткат).
- Undo/Redo в редакторах
- Текстовый редактор, графический, редактор настроек.
- Очередь задач
- Веб-приложение/CLI: очередь команд на обработку, ретраи и т.п.
- Скрипты и макросы

Пользователь записывает последовательность команд → потом запускает как один макрос.

Вызовы по сети / RPC

Команда сериализуется, отправляется на сервер, там выполняется.

### 4. Как реализовать (TypeScript пример)

4.1. Базовый интерфейс команды
```ts
// Интерфейс команды
interface Command {
    execute(): void;
    undo(): void; // опционально, если нужно Undo
}
4.2. Receiver — “исполнитель”
```
Представим простой текстовый редактор:

```ts
class TextEditor {
    private text = "";

    public addText(newText: string) {
        this.text += newText;
    }

    public removeLast(count: number) {
        this.text = this.text.slice(0, -count);
    }

    public getText() {
        return this.text;
    }
}
```
4.3. Конкретные команды
```ts
// Команда "Добавить текст"
class AddTextCommand implements Command {
    private previousLength = 0;

    constructor(private editor: TextEditor, private textToAdd: string) {}

    execute() {
        this.previousLength = this.textToAdd.length;
        this.editor.addText(this.textToAdd);
    }

    undo() {
        this.editor.removeLast(this.previousLength);
    }
}
```

Можно сделать и другие команды (удалить, заменить и т.д.).

4.4. Invoker — тот, кто выполняет и хранит историю
```ts
class CommandInvoker {
    private history: Command[] = [];

    executeCommand(command: Command) {
        command.execute();
        this.history.push(command);
    }

    undo() {
        const command = this.history.pop();
        if (command) {
            command.undo();
        }
    }
}
```
4.5. Использование
```ts
export default function commandPatternDemo() {
    const editor = new TextEditor();
    const invoker = new CommandInvoker();

    const cmd1 = new AddTextCommand(editor, "Hello, ");
    const cmd2 = new AddTextCommand(editor, "world!");

    invoker.executeCommand(cmd1);
    invoker.executeCommand(cmd2);

    console.log(editor.getText()); // "Hello, world!"

    invoker.undo();
    console.log(editor.getText()); // "Hello, "

    invoker.undo();
    console.log(editor.getText()); // ""
}
```
### 5. Пример из “реального” фронтенда: кнопка как Invoker

```ts
interface Command {
    execute(): void;
}

class ToggleSidebarCommand implements Command {
    constructor(private element: HTMLElement) {}

    execute() {
        this.element.classList.toggle("sidebar--open");
    }
}

// client
const sidebar = document.querySelector(".sidebar") as HTMLElement;
const btn = document.querySelector(".js-toggle-sidebar") as HTMLButtonElement;

const toggleSidebarCommand = new ToggleSidebarCommand(sidebar);

// invoker (кнопка)
btn.addEventListener("click", () => {
        toggleSidebarCommand.execute();
        });
```
Теперь:
- Логику можно переиспользовать (например, повесить ту же команду на hotkey).
- Кнопка не знает ничего о том, как именно открывается сайдбар.

### 6. Макрокоманда (несколько действий как одно)

```ts
class MacroCommand implements Command {
    constructor(private commands: Command[]) {}

    execute() {
        this.commands.forEach((cmd) => cmd.execute());
    }

    undo() {
        // откатываем в обратном порядке
        [...this.commands].reverse().forEach((cmd) => cmd.undo());
    }
}
```
### 7. Краткое резюме

- Что: инкапсулируем действие (запрос) в объект c execute() (+ undo()).
- Зачем: развязать отправителя и получателя, получить историю, undo/redo, очереди, макросы.
- Когда: UI-кнопки, меню, горячие клавиши, редакторы, очереди задач, макросы, RPC.
- Как: вводим интерфейс Command, конкретные команды, Invoker, Receiver, соединяем в client-коде.
