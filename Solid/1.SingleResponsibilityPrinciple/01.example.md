# SOLID S - Single Responsibility Principle(Принцип единственной ответственности)

- Когда много разработчиков правят один файл, получается много конфликтов при слиянии изменений.
- Каждый класс должен иметь одну и только одну причину для изменения.

## Примеры

### Плохо

```ts
class MyClass {
    private field_1: string;
    private field_2: string;
    public function getField1(): string {
        return this.field_1;
    }
    public function getField2(): string {
        return this.field_2;
    }
}
```

Клиент требует добавить функционал сохранения и загрузки данных

```ts
class MyClass {
    private field_1: string;
    private field_2: string;
    public function getField1(): string {
        return this.field_1;
    }
    public function getField2(): string {
        return this.field_2;
    }
    public function save(): void {
        // Логика сохранения
    }
    public function send(): void {
        // Логика загрузки
    }
}
```

Нужно добавиь еще и печать и логирование

```ts
class MyClass {
    private field_1: string;
    private field_2: string;
    public function getField1(): string {
        return this.field_1;
    }
    public function getField2(): string {
        return this.field_2;
    }
    public function save(): void {
        // Логика сохранения
    }
    public function send(): void {
        // Логика загрузки
    }
    public function print(): void {
        // Логика печати
    }
    public function log(): void {
        // Логика логирования
    }
}
```

Получается godObject, который делает все и сразу. Любое изменение в требованиях приводит к изменению этого класса.

### Хорошо

```ts
class MyClass {
    private field_1: string;
    private field_2: string;
    public function getField1(): string {
        return this.field_1;
    }
    public function getField2(): string {
        return this.field_2;
    }
}
```

Для сохранения создаем отдельный класс

```ts
class Repository {
    public function save(myClass: MyClass): void {
        // Логика сохранения
    }
    public function remove(myClass: MyClass): void {
        // Логика удаления
    }
}
```

Для отправки создаем отдельный класс

```ts
class HttpSender {
    public function send(myClass: MyClass): void {
        // Логика загрузки
    }
}
```

Когда клиент попросит добавить и получение данных, мы просто добавим метод в класс HttpSender, не трогая MyClass

```ts
class HttpSender {
    public function send(myClass: MyClass): void {
        // Логика загрузки
    }
    public function get(myClass: MyClass): MyClass {
        // Логика получения
    }
}
```

Для печати создаем отдельный класс

```ts
class Printer {
    public function print(myClass: MyClass): void {
        // Логика печати
    }
}
```

Для логирования создаем отдельный класс

```ts
class Logger {
    public function log(myClass: MyClass): void {
        // Логика логирования
    }
}
```

Теперь каждый класс отвечает только за одну вещь, и любое изменение в требованиях затрагивает только один класс.

Если нужно изменить логику сохранения, мы меняем только класс Repository, не затрагивая остальные классы.

Один разработчик может работать над MyClass, другой над Repository, третий над HttpSender и так далее,
не создавая конфликтов при слиянии изменений.

**И мы разделили модель данных (MyClass) и логику работы с этими данными (Repository, HttpSender, Printer, Logger).**
