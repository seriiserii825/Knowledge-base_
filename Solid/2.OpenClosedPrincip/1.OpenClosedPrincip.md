# SOLID O - Open/Closed Principle(Принцип открытости/закрытости)

## - Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.

Изменять существующий код рискованно, так как это может привести к появлению новых ошибок.
Вместо этого следует добавлять новый функционал путем расширения существующего кода.

Если все-таки нужно изменить существующий код, то нужно делать регрессионное тестирование,
чтобы убедиться, что изменения не сломали существующий функционал.

### Примеры (плохо)

```ts
class Weapon {
  type: string;
  damage: number;
  range: number;
  constructor(type: string, damage: number, range: number) {
    this.type = type;
    this.damage = damage;
    this.range = range;
  }
}
```

и класс персонажа, который может принимать это оружие

```ts
class Character {
  name: string;
  weapon: Weapon;
  constructor(name: string, weapon: Weapon) {
    this.name = name;
    this.weapon = weapon;
  }
  changeWeapon(newWeapon: Weapon): void {
    this.weapon = newWeapon;
  }
}

// создаем оружие
const sword = new Weapon("sword", 50, 1);

// создаем персонажа с мечом
const hero = new Character("Hero", sword);
```

после в классе оружие добавляем метод атаки

```ts
class Weapon {
  type: string;
  damage: number;
  range: number;
  constructor(type: string, damage: number, range: number) {
    this.type = type;
    this.damage = damage;
    this.range = range;
  }
  attack(): void {
    console.log(`Attacking with ${this.type} for ${this.damage} damage!`);
  }
}
```

и в классе персонажа добавляем метод атаки

```ts
class Character {
  name: string;
  weapon: Weapon;
  constructor(name: string, weapon: Weapon) {
    this.name = name;
    this.weapon = weapon;
  }
  changeWeapon(newWeapon: Weapon): void {
    this.weapon = newWeapon;
  }
  attack(): void {
    this.weapon.attack();
  }
}

// создаем оружие
const sword = new Weapon("sword", 50, 1);
// создаем персонажа с мечом
const hero = new Character("Hero", sword);
// персонаж атакует
hero.attack(); // Attacking with sword for 50 damage!
```

Создаем новое оружие арбалет и меняем оружие персонажа

```ts
class Weapon {
  type: string;
  damage: number;
  range: number;
  constructor(type: string, damage: number, range: number) {
    this.type = type;
    this.damage = damage;
    this.range = range;
  }
  attack(): void {
    if (this.type === "sword") {
      console.log(`Attacking with ${this.type} for ${this.damage} damage!`);
    } else if (this.type === "crossbow") {
      console.log(`Shooting with ${this.type} for ${this.damage} damage!`);
    }
  }
}

const crossbow = new Weapon("crossbow", 40, 10);
hero.changeWeapon(crossbow);
hero.attack(); // Attacking with crossbow for 40 damage!
```

На этот момент мы нарушили принцип открытости/закрытости, так как нам пришлось изменить
класс Weapon, чтобы добавить новый тип оружия.

Добавим интерфейс Attacker и метод attack в каждый класс оружия
И избавляемся от свойства type в классе Weapon

```ts
interface Attacker {
  attack(): void;
}
class Weapon implements Attacker {
  damage: number;
  range: number;
  constructor(damage: number, range: number) {
    this.type = type;
    this.damage = damage;
    this.range = range;
  }
  attack(): void {}
}

class Sword extends Weapon {
  constructor(damage: number, range: number) {
    super(damage, range);
  }
  attack(): void {
    console.log(`Attacking with sword for ${this.damage} damage!`);
  }
}

class Crossbow extends Weapon {
  constructor(damage: number, range: number) {
    super(damage, range);
  }
  attack(): void {
    console.log(`Shooting with crossbow for ${this.damage} damage!`);
  }
}

// создаем оружие
const sword = new Sword(50, 1);
const crossbow = new Crossbow(40, 10);
// создаем персонажа с мечом
const hero = new Character("Hero", sword);
// персонаж атакует
hero.attack(); // Attacking with sword for 50 damage!
hero.changeWeapon(crossbow);
hero.attack(); // Shooting with crossbow for 40 damage!
```

Теперь мы можем добавлять новые типы оружия, не изменяя существующий код класса Weapon.

Например нужно добавить еще нож

```ts
class Dagger extends Weapon {
  constructor(damage: number, range: number) {
    super(damage, range);
  }
  attack(): void {
    console.log(`Stabbing with dagger for ${this.damage} damage!`);
  }
}
const dagger = new Dagger(30, 1);
hero.changeWeapon(dagger);
hero.attack(); // Stabbing with dagger for 30 damage!
```

## Профит

- отпадает необходимость вносить изменения в существующий код, регрессии
- упрощается добавление нового функционала
- улучшается читаемость и поддерживаемость кода
- повышается надежность системы
- облегчается тестирование
- нужно выявить сущности, которые будут меняться, и создать для них абстракции

