# Person

```ts
class Person {
  fullname: string;
  constructor(fullname: string) {
    this.fullname = fullname;
  }
}
class PersonList {
  persons: Person[];
  constructor(persons: Person[]) {
    this.persons = persons;
  }
}
class BubbleSort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
class QuickSort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
class MergeSort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
```

В PersonList нужно добавить сортировку

```ts
class PersonList {
  persons: Person[];
  constructor(persons: Person[]) {
    this.persons = persons;
  }
  sort() {
    BubbleSort.sort(this.persons);
  }
}
```

Добавляем еще один класс Music и сортируем

```ts
class Music {
  title: string;
  constructor(title: string) {
    this.title = title;
  }
}
class MusicList {
  musics: Music[];
  constructor(musics: Music[]) {
    this.musics = musics;
  }
  sort() {
    BubbleSort.sort(this.musics);
  }
}
```

Позже приходит требование сортировать по условию

```ts
class PersonList {
  persons: Person[];
  constructor(persons: Person[]) {
    this.persons = persons;
  }
  sort() {
    if (this.persons.length < 10) {
      BubbleSort.sort(this.persons);
    } else if (this.persons.length < 100) {
      MergeSort.sort(this.persons);
    } else {
      QuickSort.sort(this.persons);
    }
  }
}
```

Нарушен принцип единственной ответственности и открытости/закрытости

Приходится изменять класс PersonList и MusicList при добавлении новых требований к сортировке

```ts
class MusicList {
  musics: Music[];
  constructor(musics: Music[]) {
    this.musics = musics;
  }
  sort() {
    if (this.musics.length < 10) {
      BubbleSort.sort(this.musics);
    } else if (this.musics.length < 100) {
      MergeSort.sort(this.musics);
    } else {
      QuickSort.sort(this.musics);
    }
  }
}
```

Улучшаем код, вводя статический класс Sort

```ts
class Sort {
  public static sort(array: []): [];
}
class BubbleSort extends Sort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
class QuickSort extends Sort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
class MergeSort extends Sort {
  public static sort(array: []): [] {
    // sorting logic
    return array;
  }
}
```

И создаем класс SortStrategy для выбора стратегии сортировки

```ts
class SortStrategy extends Sort {
  public static sort(array: []): [] {
    if (array.length < 10) {
      return BubbleSort.sort(array);
    } else if (array.length < 100) {
      return MergeSort.sort(array);
    } else {
      return QuickSort.sort(array);
    }
  }
}
```
Теперь классы PersonList и MusicList не зависят от конкретных реализаций сортировки

```ts
class PersonList {
  persons: Person[];
  constructor(persons: Person[]) {
    this.persons = persons;
  }
  sort() {
    SortStrategy.sort(this.persons);
  }
}
class MusicList {
  musics: Music[];
  constructor(musics: Music[]) {
    this.musics = musics;
  }
  sort() {
    SortStrategy.sort(this.musics);
  }
}
```

Теперь при добавлении новых стратегий сортировки не нужно изменять классы PersonList и MusicList
