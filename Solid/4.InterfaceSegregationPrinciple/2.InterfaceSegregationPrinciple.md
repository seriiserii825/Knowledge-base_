# Interface Segregation Principle (Принцип разделения интерфейсов, ISP)

## Примеры

ниже — понятные примеры принципа разделения интерфейсов (ISP). Суть: клиенты не должны зависеть от методов, которые они не используют. Лучше несколько маленьких интерфейсов по ролям/способностям, чем «толстый» общий.

### 1) Repo: чтение и запись раздельно (самый практичный для твоих проектов)

Плохо (толстый интерфейс)

```ts
interface PostRepository {
  findAll(): Post[];
  findOne(id: number): Post | null;
  create(p: Post): void;
  update(p: Post): void;
  delete(id: number): void;
}

// Клиент, которому нужно только чтение, вынужден «знать» про create/update/delete
function renderList(repo: PostRepository) {
  return repo.findAll().map((p) => p.title);
}
```

### Хорошо (сегрегация по задачам)

```ts
interface ReadRepository<T, ID = number> {
  findAll(): T[];
  findOne(id: ID): T | null;
}
interface WriteRepository<T, ID = number> {
  create(entity: T): void;
  update(entity: T): void;
  delete(id: ID): void;
}

// Клиенты зависят только от нужной части:
function renderList(repo: ReadRepository<Post>) {
  return repo.findAll().map((p) => p.title);
}
function importDump(repo: WriteRepository<Post>) {
  // только запись
}
```

Где удобно применить у тебя

- LocalStorage/Cache — часто только чтение на SSR и полная запись на CSR.
- Разные источники: ReadRepository может быть обёрткой над REST/GraphQL, WriteRepository — над WP REST POST/PUT/DELETE.
- Тесты: легко мокать отдельно чтение и запись.
