# Interface Segregation Principle(Принцип разделения интерфейсов, ISP)

Является одним из пяти основных принципов объектно-ориентированного программирования, известных как SOLID. Этот принцип был сформулирован Робертом Мартином и гласит:

Программные сущности не должны зависеть от методов, которые они не используют.

Он сильно пересекается с первым принципом SOLID — Принципом единственной ответственности (SRP). В то время как SRP фокусируется на том, чтобы класс имел только одну причину для изменения, ISP подчеркивает важность создания специализированных интерфейсов, которые соответствуют конкретным потребностям клиентов.

А также с 3 принципом SOLID — Принципом подстановки Лисков (LSP). В то время как LSP требует, чтобы подклассы могли заменять свои базовые классы без нарушения корректности программы, ISP требует, чтобы клиенты не были вынуждены зависеть от интерфейсов, которые они не используют.

Нельзя заставлять клиента реализовывать интерфейс, который ему не нужен. Вместо этого следует создавать более мелкие и специализированные интерфейсы, которые соответствуют конкретным потребностям клиентов.

## Пример нарушения ISP

```ts
interface Attacker {
  attack(): void;
}
class Pistol implements Attacker {
  attack(): void {
    console.log("Pistolet стреляeт");
  }
}
```

Добавляем еще метод reload в интерфейс Attacker

```ts
interface Attacker {
  attack(): void;
  reload(): void;
}
class Pistol implements Attacker {
  attack(): void {
    console.log("Pistolet стреляeт");
  }
  reload(): void {
    console.log("Pistolet перезаряжается");
  }
}
```

Добавляем еще оружие RPG

```ts
class RPG implements Attacker {
  attack(): void {
    console.log("RPG стреляет");
  }
  reload(): void {
    throw new Error("RPG не перезаряжается");
  }
}
```

Добавляем еще оружие Knife

```ts
class Knife implements Attacker {
  attack(): void {
    console.log("Нож режет");
  }
  reload(): void {
    throw new Error("Нож не перезаряжается");
  }
}
```

Но нож не перезаряжается. Мы нарушили принцип ISP.

## Пример соблюдения ISP
```ts
interface Attacker {
  attack(): void;
}
interface Reloader {
  reload(): void;
}
class Pistol implements Attacker, Reloader {
  attack(): void {
    console.log("Pistolet стреляeт");
  }
  reload(): void {
    console.log("Pistolet перезаряжается");
  }
}
class RPG implements Attacker, Reloader {
  attack(): void {
    console.log("RPG стреляет");
  }
  reload(): void {
    console.log("RPG перезаряжается");
  }
}
class Knife implements Attacker {
  attack(): void {
    console.log("Нож режет");
  }
}
```
