# Interface Segregation Principle(Принцип разделения интерфейсов, ISP)

Пересечение простое:

SRP говорит: «Класс (модуль) не должен делать слишком много».
ISP говорит: «Интерфейс не должен заставлять клиентов делать слишком много».

Когда у тебя есть толстый интерфейс, которым пользуются разные классы-клиенты, он почти автоматически приводит к нарушению SRP у этих классов: каждый из них вынужден брать на себя лишние обязанности → у класса появляется несколько причин для изменения.

Интуитивно, в двух фразах

- SRP — про реализацию: не делай «Божество-класс» (God object), у каждого класса должна быть одна зона ответственности.
- ISP — про контракт: не делай «Божество-интерфейс», разделяй интерфейсы так, чтобы каждый клиент брал только то, что ему реально нужно.

Из-за этого они и «пересекаются»: толстый интерфейс = клиенты нарушают SRP, потому что им приходится реализовывать/поддерживать методы, которые к их ответственности не относятся.
Пример в TypeScript: нарушение SRP + ISP

## 1. Плохой вариант: один жирный интерфейс

```ts
// "Толстый" интерфейс - нарушение ISP
interface Worker {
  workOnBackend(): void;
  workOnFrontend(): void;
  manageTeam(): void;
}
class FullstackTeamLead implements Worker {
  workOnBackend(): void {
    console.log("Implementing backend features");
  }
  workOnFrontend(): void {
    console.log("Implementing frontend features");
  }
  manageTeam(): void {
    console.log("Managing the team");
  }
}
// А теперь разработчик, который по идее только фронтендер
class FrontendDeveloper implements Worker {
  workOnBackend(): void {
    // ЗАСТАВИЛИ реализовать, хотя ему это не нужно
    throw new Error("I don't do backend");
  }
  workOnFrontend(): void {
    console.log("Implementing frontend features");
  }
  manageTeam(): void {
    // И это тоже лишнее
    throw new Error("I don't manage a team");
  }
}
```

## Что тут нарушено?

ISP:

FrontendDeveloper — клиент интерфейса Worker, но ему не нужны workOnBackend и manageTeam.
Интерфейс слишком общий, не «подогнан» под нужды клиентов.

SRP:

FullstackTeamLead делает и backend, и frontend, и management.

У класса минимум три причины измениться:

- изменились правила управления командой → правим manageTeam;
- изменились требования к backend → правим workOnBackend;
- изменились требования к frontend → правим workOnFrontend.

Это нарушение принципа единственной ответственности.

Хороший вариант: разделяем интерфейсы (ISP) → классы становятся чище (SRP)

```ts
// Разделяем обязанности на специализированные интерфейсы
interface BackendWorker {
  workOnBackend(): void;
}
interface FrontendWorker {
  workOnFrontend(): void;
}
interface TeamLead {
  manageTeam(): void;
}
// Теперь каждый класс реализует только то, что ему реально нужно
class BackendDeveloper implements BackendWorker {
  workOnBackend(): void {
    console.log("Implementing backend features");
  }
}
class FrontendDeveloper2 implements FrontendWorker {
  workOnFrontend(): void {
    console.log("Implementing frontend features");
  }
}
// Тимлид, который занимается только менеджментом
class PureTeamLead implements TeamLead {
  manageTeam(): void {
    console.log("Managing the team");
  }
}
// Если у тебя реально есть фуллстек-тимлид — он СВЯЗНО объединяет роли
class FullstackTeamLead2 implements BackendWorker, FrontendWorker, TeamLead {
  workOnBackend(): void {
    console.log("Implementing backend features");
  }
  workOnFrontend(): void {
    console.log("Implementing frontend features");
  }
  manageTeam(): void {
    console.log("Managing the team");
  }
}
```

## Что стало лучше?


ISP:

- BackendDeveloper реализует только BackendWorker.
- FrontendDeveloper2 реализует только FrontendWorker.
- PureTeamLead реализует только TeamLead.

Никто не вынужден реализовывать «левые» методы.

SRP:

- BackendDeveloper отвечает только за backend.
- FrontendDeveloper2 только за frontend.
- PureTeamLead только за управление.

У каждого класса одна основная причина для изменения.

FullstackTeamLead2 реализует несколько интерфейсов, но это уже осознанное объединение ролей. Если тебе нужно — можешь потом разделить его на два класса и использовать композицию, чтобы ещё сильнее соблюсти SRP.
